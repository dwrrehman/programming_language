=========================================
   manual for the arm 64 bit assembler
=========================================


imm16 sh2 Rd movzx      move zero 64
imm16 sh2 Rd movzw	move zero 32

imm16 sh2 Rd movkx	move keep 64
imm16 sh2 Rd movkw	move keep 32

imm16 sh2 Rd movnx	move negate 64
imm16 sh2 Rd movnw	move negate 32


imm16 hw Rd addix	add immediate 64
imm16 hw Rd addiw	add immediate 32

imm16 hw Rd addhx	add high immediate 64
imm16 hw Rd addhw	add high immediate 32

imm16 hw Rd addixs	add immediate 64 set flag
imm16 hw Rd addiws	add immediate 32 set flag

imm16 hw Rd addhxs	add high immediate 64 set flag
imm16 hw Rd addhws	add high immediate 32 set flag


imm6 sh2 Rm Rn Rd addx		add shifted register 64
imm6 sh2 Rm Rn Rd addw		add shifted register 32

imm6 sh2 Rm Rn Rd addxs		add shifted register 64 set flag
imm6 sh2 Rm Rn Rd addws		add shifted register 32 set flag


Rm Rn Rd adcx		add with carry 64
Rm Rn Rd adcw		add with carry 32

Rm Rn Rd adcxs		add with carry 64 set flag
Rm Rn Rd adcws		add with carry 32 set flag


Rn Rd absx
Rn Rd absw

Rn Rd clzx
Rn Rd clzw

Rn Rd clsx
Rn Rd clsw

Rn Rd ctzx
Rn Rd ctzw

Rn Rd cntx
Rn Rd cntw


Rn Rd rbitx
Rn Rd rbitw

Rn Rd revx
Rn Rd revw

Rn Rd revhx
Rn Rd revhw

Rn Rd ld64b
Rn Rd st64b









Rn br	 	branch on register 

nop		no operation

svc		supervisor system call

cfinv		invert carry flag








compiletime instructions:
=================================

rd  =  overwritten destination register
rn  =  first source register
rm  =  second source register 
rs  =  code-address source register


rd ctincr
rd ctzero

rm rn rs ctblt       (rn < rm)
rd ctpc
rs ctstop
rm rn rs ctflt       (rn < rm)

rm rn rd ctadd
rm rn rd ctsub       (rn - rm)
rm rn rd ctmul
rm rn rd ctdiv       (rn / rm)
rm rn rd ctrem       (rn % rm)

rm rn rd ctxor
rm rn rd ctor
rm rn rd ctand
rm rn rd ctnor
rm rn rd ctshl       (rn << rm)
rm rn rd ctshr       (rn >> rm)

rn ctprint

rn rd ctld1          (rd = *rn)
rn rd ctld2
rn rd ctld4
rn rd ctld8

rn rd ctst1          (*rd = rn)
rn rd ctst2
rn rd ctst4
rn rd ctst8
	
















code:






	if (op == ctstop) {if (registers[a0] == stop) stop = 0; arg_count = 0; return; }
	else if (stop) return;

	if (false) {}
	else if (op == ctat)   registers[a0] = ins_count;
	else if (op == ctpc)   registers[a0] = *pc;
	else if (op == ctgoto) *pc = registers[a0]; 
	else if (op == ctblt)  { if (registers[a1] < registers[a0]) stop = registers[a2]; } 
	else if (op == ctincr) registers[a0]++; 
	else if (op == ctzero) registers[a0] = 0; 
	else if (op == ctadd)  registers[a2] = registers[a1] + registers[a0]; 
	else if (op == ctsub)  registers[a2] = registers[a1] - registers[a0]; 
	else if (op == ctmul)  registers[a2] = registers[a1] * registers[a0]; 
	else if (op == ctdiv)  registers[a2] = registers[a1] / registers[a0]; 
	else if (op == ctrem)  registers[a2] = registers[a1] % registers[a0]; 
	else if (op == ctxor)  registers[a2] = registers[a1] ^ registers[a0]; 
	else if (op == ctor)   registers[a2] = registers[a1] | registers[a0]; 
	else if (op == ctand)  registers[a2] = registers[a1] & registers[a0]; 
	else if (op == ctnor)  registers[a2] = ~(registers[a1] | registers[a0]); 
	else if (op == ctshl)  registers[a2] = registers[a1] << registers[a0]; 
	else if (op == ctshr)  registers[a2] = registers[a1] >> registers[a0]; 
	else if (op == ctprint)  printf("debug: \033[32m%llu\033[0m\n", registers[a0]); 

	else if (op == ctld1)  registers[a1] = *(uint8_t*) registers[a0]; 
	else if (op == ctld2)  registers[a1] = *(uint16_t*)registers[a0]; 
	else if (op == ctld4)  registers[a1] = *(uint32_t*)registers[a0]; 
	else if (op == ctld8)  registers[a1] = *(uint64_t*)registers[a0]; 

	else if (op == ctst1)  *(uint8_t*) registers[a1] = (uint8_t)  registers[a0]; 
	else if (op == ctst2)  *(uint16_t*)registers[a1] = (uint16_t) registers[a0]; 
	else if (op == ctst4)  *(uint32_t*)registers[a1] = (uint32_t) registers[a0]; 
	else if (op == ctst8)  *(uint64_t*)registers[a1] = (uint64_t) registers[a0]; 
	




















static void generate(void) {

	for (nat i = 0; i < ins_count; i++) {

		const nat op = ins[i].op;
		struct argument* const a = ins[i].arguments;

		     if (op == svc)    emit(0xD4000001);
		else if (op == nop)    emit(0xD503201F);
		else if (op == cfinv)  emit(0xD500401F);
		else if (op == br)     emit(generate_br(a));

		else if (op == absx)   emit(generate_abs(a, 1, 0x16B008U));
		else if (op == absw)   emit(generate_abs(a, 0, 0x16B008U));
		else if (op == clzx)   emit(generate_abs(a, 1, 0x16B004U));
		else if (op == clzw)   emit(generate_abs(a, 0, 0x16B004U));
		else if (op == clsx)   emit(generate_abs(a, 1, 0x16B005U));
		else if (op == clsw)   emit(generate_abs(a, 0, 0x16B005U));
		else if (op == ctzx)   emit(generate_abs(a, 1, 0x16B006U));
		else if (op == ctzw)   emit(generate_abs(a, 0, 0x16B006U));
		else if (op == cntx)   emit(generate_abs(a, 1, 0x16B007U));
		else if (op == cntw)   emit(generate_abs(a, 0, 0x16B007U));
		else if (op == rbitx)  emit(generate_abs(a, 1, 0x16B000U));
		else if (op == rbitw)  emit(generate_abs(a, 0, 0x16B000U));
		else if (op == revx)   emit(generate_abs(a, 1, 0x16B003U));
		else if (op == revw)   emit(generate_abs(a, 1, 0x16B002U));
		else if (op == revhx)  emit(generate_abs(a, 1, 0x16B001U));
		else if (op == revhw)  emit(generate_abs(a, 0, 0x16B001U));
		else if (op == ld64b)  emit(generate_abs(a, 1, 0x1E0FF4U));
		else if (op == st64b)  emit(generate_abs(a, 1, 0x1E0FE4U));

		else if (op == movzx)  emit(generate_mov(a, 1, 0xA5U));
		else if (op == movzw)  emit(generate_mov(a, 0, 0xA5U));
		else if (op == movkx)  emit(generate_mov(a, 1, 0xE5U));
		else if (op == movkw)  emit(generate_mov(a, 0, 0xE5U));
		else if (op == movnx)  emit(generate_mov(a, 1, 0x25U));
		else if (op == movnw)  emit(generate_mov(a, 0, 0x25U));

		else if (op == addix)  emit(generate_addi(a, 1, 0, 0x22U));
		else if (op == addiw)  emit(generate_addi(a, 0, 0, 0x22U));
		else if (op == addhx)  emit(generate_addi(a, 1, 1, 0x22U));
		else if (op == addhw)  emit(generate_addi(a, 0, 1, 0x22U));
		else if (op == addixs) emit(generate_addi(a, 1, 0, 0x62U));
		else if (op == addiws) emit(generate_addi(a, 0, 0, 0x62U));
		else if (op == addhxs) emit(generate_addi(a, 1, 1, 0x62U));
		else if (op == addhws) emit(generate_addi(a, 0, 1, 0x62U));

		else if (op == adcx)   emit(generate_adc(a, 1, 0x0D0U, 0x00));
		else if (op == adcw)   emit(generate_adc(a, 0, 0x0D0U, 0x00));
		else if (op == adcxs)  emit(generate_adc(a, 1, 0x1D0U, 0x00));
		else if (op == adcws)  emit(generate_adc(a, 0, 0x1D0U, 0x00));
		else if (op == asrvx)  emit(generate_adc(a, 1, 0x0D6U, 0x0A));
		else if (op == asrvw)  emit(generate_adc(a, 0, 0x0D6U, 0x0A));

		//else if (op == cselx)  emit(generate_adc(a, 0, 0x0D6U, 0x0A));
		//else if (op == cselx)  emit(generate_adc(a, 0, 0x0D6U, 0x0A));

		else if (op == orrx)   emit(generate_orr(a, 1, 0, 0x2AU));
		else if (op == orrw)   emit(generate_orr(a, 0, 0, 0x2AU));
		else if (op == ornx)   emit(generate_orr(a, 1, 1, 0x2AU));
		else if (op == ornw)   emit(generate_orr(a, 0, 1, 0x2AU));
		else if (op == addx)   emit(generate_orr(a, 1, 0, 0x0BU));
		else if (op == addw)   emit(generate_orr(a, 0, 0, 0x0BU));
		else if (op == addxs)  emit(generate_orr(a, 1, 0, 0x2BU));
		else if (op == addws)  emit(generate_orr(a, 0, 0, 0x2BU));
		else if (op == subx)   emit(generate_orr(a, 1, 0, 0x4BU));
		else if (op == subw)   emit(generate_orr(a, 0, 0, 0x4BU));
		else if (op == subxs)  emit(generate_orr(a, 1, 0, 0x6BU));
		else if (op == subws)  emit(generate_orr(a, 0, 0, 0x6BU));
		else {
			printf("error: unknown instruction: %llu\n", op);
			printf("       unknown instruction: %s\n", instruction_spelling[op]);
			abort();
		}
	}
}



